## üß© Concetti chiave

|Concetto|Descrizione|
|---|---|
|**Message**|Un‚Äôunit√† di dati codificata in base64, schema-agnostica (XML, JSON, CSV, GZIP). Producer e consumer devono concordare il formato.|
|**Key**|Identificatore usato per il partizionamento: messaggi con la stessa key finiscono nella stessa **partition**.|
|**Partition**|Sezione di uno stream. Ogni messaggio ha un **offset**. Le partizioni permettono scalabilit√† orizzontale e lettura parallela.|
|**Stream Pool**|Raggruppamento logico di stream con configurazioni condivise (cifratura, accesso, endpoint privati).|
|**Offset**|Identificatore univoco di un messaggio all‚Äôinterno di una partizione. I consumer possono leggere da qualsiasi offset.|
|**Cursor**|Puntatore a una posizione specifica nello stream, usato per leggere/scrivere dati. Pu√≤ essere spostato avanti o indietro.|
|**Consumer Group**|Gruppo di consumer che coordina la lettura da tutte le partizioni. Supporta bilanciamento e resilienza.|

---

## üîÑ Flusso di esecuzione

Un **producer** pubblica messaggi su uno **stream**, che vengono poi distribuiti tra le **partizioni** utilizzando la chiave del messaggio. Le partizioni permettono di distribuire uno stream suddividendo i messaggi su pi√π nodi, consentendo cos√¨ a pi√π **consumer** di leggere lo stream in parallelo.  
Ogni messaggio all‚Äôinterno di uno stream √® contrassegnato da un valore di **offset**, che permette a un consumer di riprendere la lettura dal punto in cui era stato interrotto.  
Inoltre, un **consumer group** √® un insieme di consumer che coordinano il consumo dei messaggi da tutte le partizioni di uno stream. I gruppi di consumer facilitano anche il **bilanciamento del carico** quando nuovi consumer si uniscono al gruppo, e il **riequilibrio** quando alcuni consumer lo abbandonano.
![[Pasted image 20250902115020.png]]

```
[Producer]
   ‚îÇ
   ‚ñº
[Stream]
   ‚îú‚îÄ Distribuzione su Partizioni (via Key)
   ‚îú‚îÄ Ogni messaggio ha un Offset
   ‚ñº
[Consumer Group]
   ‚îú‚îÄ Lettura parallela da pi√π partizioni
   ‚îú‚îÄ Coordinamento e bilanciamento
   ‚ñº
[Consumer]
```

- I messaggi sono distribuiti tra le partizioni in base alla **key**
- Ogni messaggio ha un **offset** che consente ai consumer di riprendere la lettura in caso di interruzione
- I **consumer group** gestiscono la lettura coordinata e il commit degli offset

---

## üìà Specifiche tecniche

|Parametro|Valore|
|---|---|
|**Retention**|Fino a 7 giorni|
|**Max message size**|1 MB|
|**Write rate per partition**|1.000 msg/sec (1 MB/sec)|
|**Read rate per partition**|5 API/sec (2 MB/sec)|
|**Partizioni per tenancy (default)**|5 (espandibile su richiesta)|

---

## üõ†Ô∏è Vantaggi rispetto a Kafka su VM

- **Zero gestione**: niente provisioning, patching, scaling manuale
- **Pay-per-use**: costi runtime ridotti, nessuna capacit√† preallocata
- **Integrazione nativa**: con OCI Functions, Logging, Monitoring
- **SDK multipli**: Java, Python, JS, .NET, Go
- **SLA 99.95%**: alta disponibilit√† e fault tolerance
- **Migrazione semplificata**: compatibilit√† Kafka per cluster esistenti

---

## ‚öôÔ∏è Come usare OSS

1. **Creazione dello stream**
    
    - Manualmente via Console
    - Automatizzato via CLI, API REST o Resource Manager
2. **Configurazione dello stream**
    
    - Appartenenza a uno Stream Pool esistente o nuovo
    - Impostazione del periodo di retention (max 7 giorni)
    - Numero di partizioni ‚Üí es. 10 partizioni = 10 MB/sec input, 20 MB/sec output

---

## üß† Quiz finale

**Domanda:** Qual √® il puntatore a una posizione specifica nello stream?

1. Partition
2. Offset
3. Key
4. Cursor

**‚úÖ Risposta corretta:** (4)  
**üßæ Spiegazione:** Il **cursor** √® un puntatore che consente di leggere/scrivere dati in una posizione specifica dello stream. Pu√≤ essere spostato per navigare tra i messaggi.

---
